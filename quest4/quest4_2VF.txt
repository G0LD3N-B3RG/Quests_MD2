QUESTÃO 4 PARTE 2 (EXTRA)
Aluno: [Gabriel Goldenberg Moita]
Matrícula: [211061752]

=================
RESPOSTAS V OU F:
=================

1. V  
2. F  
3. V  
4. F  
5. F  
6. V  
7. F

==============================
    Explicação do (V ou F)
==============================

1. (V): A função inversoModular usa o algoritmo estendido de Euclides (com coeficientes x0/x1 para os coeficientes de Bézout, onde ax + my = 1),
retornando x1 como o inverso de a mod m, desde que gcd(a, m) = 1.

2. (F): O algoritmo estendido só garante um inverso se gcd(G, Zn) = 1 (condição implícita para existência do inverso modular).
Se gcd ≠ 1, o loop termina com m ≠ 0 ou x1 inválido, mas o código não verifica isso explicitamente (ele assume coprimos e pode retornar um valor incorreto sem erro).

3. (V): Na aritmética modular, dividir H por G é multiplicar H pelo inverso modular de G (pois H / G ≡ H * G^{-1} mod Zn), e o % Zn garante o resto.

4. (F): O `powMod` usa exponenciação binária (quadrado-e-multiplicar) sem redução de expoente. 
Não há verificação se n1 é primo nem aplicação de Fermat (a^{p-1} ≡ 1 mod p para redução x mod (p-1)).

5. (F): Ela usa otimização: exponenciação binária (while exp > 0, verifica bit ímpar com exp % 2,
quadrado de base e shift exp >>= 1), que é O(log x) em vez de O(x) multiplicações diretas.

6. (V): No final tem um if (x1 < 0) que soma m0 (o módulo original), pra deixar o inverso positivo e no range certo [0, m-1]. 
Para não dar problema.

7. (F): Não há cálculo de φ(n1) em lugar nenhum no código. O `powMod` não usa Euler/Fermat para redução (não há % φ(n1)), 
independentemente de n1 ser primo ou não, ele sempre faz exponenciação binária direta.